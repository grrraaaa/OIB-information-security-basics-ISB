<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–ö—Ä–∏–ø—Ç–æ –ó–∞–¥–∞–Ω–∏–µ: –í–∞—Ä–∏–∞–Ω—Ç 7</title>
  <style>
    body {
      font-family: 'Segoe UI', sans-serif;
      background: #1e1e2f;
      color: #f0f0f0;
      padding: 40px;
    }
    h1 {
      color: #4fd1c5;
    }
    button {
      padding: 10px 20px;
      margin: 10px 10px 20px 0;
      background-color: #4fd1c5;
      border: none;
      border-radius: 8px;
      color: #1e1e2f;
      font-weight: bold;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background-color: #38b2ac;
    }
    pre {
      background: #2d2d3a;
      padding: 20px;
      border-radius: 10px;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
  <h1>–ö—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—è: —Ñ–∞–º–∏–ª–∏—è "–ì—É–ª–µ–≤–∏—á"</h1>
  <button onclick="generateRandomNumbers()">–ó–∞–¥–∞–Ω–∏–µ 2: –°–ª—É—á–∞–π–Ω—ã–µ —á–∏—Å–ª–∞</button>
  <button onclick="runVariant7()">–ó–∞–¥–∞–Ω–∏–µ 3: AES-GCM + SHA384</button>
  <button onclick="runKeyWrapping()">–ó–∞–¥–∞–Ω–∏–µ 4: AES-KW –£–ø–∞–∫–æ–≤–∫–∞/–†–∞—Å–ø–∞–∫–æ–≤–∫–∞</button>
  <button onclick="runECDSA()">–ó–∞–¥–∞–Ω–∏–µ 5: ECDSA –ü–æ–¥–ø–∏—Å—å/–ü—Ä–æ–≤–µ—Ä–∫–∞</button>

  <pre id="output"></pre>

  <script>
    const output = document.getElementById('output');
    const surname = "–ì—É–ª–µ–≤–∏—á";
    let generatedKey = null;

    // –ó–∞–¥–∞–Ω–∏–µ 2: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª
    function generateRandomNumbers() {
      output.textContent = "üî¢ –ó–∞–¥–∞–Ω–∏–µ 2: –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª\n\n";
      const randomValues = crypto.getRandomValues(new Uint8Array(16));
      
      output.textContent += `${randomValues}`;
    }

    // –ó–∞–¥–∞–Ω–∏–µ 3: AES-GCM + SHA384
    async function runVariant7() {
      output.textContent = "üîê –ó–∞–¥–∞–Ω–∏–µ 3: AES-GCM + SHA-384\n\n";
      const enc = new TextEncoder();
      const dec = new TextDecoder();

      generatedKey = await crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );

      const iv = crypto.getRandomValues(new Uint8Array(12));
      const ciphertext = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv: iv },
        generatedKey,
        enc.encode(surname)
      );

      const decrypted = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv: iv },
        generatedKey,
        ciphertext
      );

      const hashBuffer = await crypto.subtle.digest("SHA-384", enc.encode(surname));
      const hashHex = [...new Uint8Array(hashBuffer)]
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');

      output.textContent += `–ò—Å—Ö–æ–¥–Ω–∞—è —Ñ–∞–º–∏–ª–∏—è: ${surname}\n`;
      output.textContent += `–°–ª—É—á–∞–π–Ω—ã–π IV (hex): ${Array.from(iv).map(b => b.toString(16).padStart(2, '0')).join('')}\n`;
      output.textContent += `–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ (Base64): ${btoa(String.fromCharCode(...new Uint8Array(ciphertext)))}\n`;
      output.textContent += `–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ: ${dec.decode(decrypted)}\n`;
      output.textContent += `SHA-384 —Ö–µ—à: ${hashHex}\n`;
    }

    // –ó–∞–¥–∞–Ω–∏–µ 4: –£–ø–∞–∫–æ–≤–∫–∞ –∏ —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∞ –∫–ª—é—á–∞ AES-KW
    async function runKeyWrapping() {
      output.textContent = "üîê –ó–∞–¥–∞–Ω–∏–µ 4: AES-KW –£–ø–∞–∫–æ–≤–∫–∞ –∏ —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∞ –∫–ª—é—á–∞\n\n";
      
      if (!generatedKey) {
        output.textContent += "–°–Ω–∞—á–∞–ª–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –ó–∞–¥–∞–Ω–∏–µ 3 –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–∞!\n";
        return;
      }

      const wrappingKey = await crypto.subtle.generateKey(
        { name: "AES-KW", length: 256 },
        true,
        ["wrapKey", "unwrapKey"]
      );

      const exportedKey = await crypto.subtle.exportKey("raw", generatedKey);
      const wrappedKey = await crypto.subtle.wrapKey(
        "raw",
        generatedKey,
        wrappingKey,
        "AES-KW"
      );

      const unwrappedKey = await crypto.subtle.unwrapKey(
        "raw",
        wrappedKey,
        wrappingKey,
        "AES-KW",
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );

      output.textContent += `–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á (hex): ${Array.from(new Uint8Array(exportedKey)).map(b => b.toString(16).padStart(2, '0')).join('')}\n`;
      output.textContent += `–£–ø–∞–∫–æ–≤–∞–Ω–Ω—ã–π –∫–ª—é—á (Base64): ${btoa(String.fromCharCode(...new Uint8Array(wrappedKey)))}\n`;
      output.textContent += `–ö–ª—é—á —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å–ø–∞–∫–æ–≤–∞–Ω: ${unwrappedKey.algorithm.name === "AES-GCM" ? "–î–∞" : "–ù–µ—Ç"}\n`;
    }

    // –ó–∞–¥–∞–Ω–∏–µ 5: ECDSA –ø–æ–¥–ø–∏—Å—å –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞
    async function runECDSA() {
      output.textContent = "üîê –ó–∞–¥–∞–Ω–∏–µ 5: ECDSA –ü–æ–¥–ø–∏—Å—å –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞\n\n";
      const enc = new TextEncoder();

      const keyPair = await crypto.subtle.generateKey(
        {
          name: "ECDSA",
          namedCurve: "P-256"
        },
        true,
        ["sign", "verify"]
      );

      const signature = await crypto.subtle.sign(
        {
          name: "ECDSA",
          hash: "SHA-256",
        },
        keyPair.privateKey,
        enc.encode(surname)
      );

      const isValid = await crypto.subtle.verify(
        {
          name: "ECDSA",
          hash: "SHA-256",
        },
        keyPair.publicKey,
        signature,
        enc.encode(surname)
      );

      output.textContent += `–°–æ–æ–±—â–µ–Ω–∏–µ: ${surname}\n`;
      output.textContent += `–ü–æ–¥–ø–∏—Å—å (Base64): ${btoa(String.fromCharCode(...new Uint8Array(signature)))}\n`;
      output.textContent += `–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∏: ${isValid ? "–£—Å–ø–µ—à–Ω–æ" : "–ù–µ—É–¥–∞—á–∞"}\n`;
    }
  </script>
</body>
</html>